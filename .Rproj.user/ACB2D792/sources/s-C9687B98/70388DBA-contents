###############################################################

## Practical conservation of bats in subterranean habitats
## Meierhofer M., ... Mammola S.

## ------------------------------------------------------------------------
# 'R script to reproduce the analyses'
## ------------------------------------------------------------------------

# Analysis performed with R (v. R 4.1.0) and R studio (v. 1.4.1103)
# Authors (code): Stefano Mammola & Melissa B. Meierhofer

###############################################################

# clean the workspace -----------------------------------------------------

rm(list = ls())

# Loading R package -------------------------------------------------------

library("metafor")   # Meta-Analysis Package for R
library("ggplot2")       
library("tidyverse")


library("circlize")      
library("cowplot")
library("dplyr")         
library("ggplot2")       
library("ggpubr")
library("grid")
library("gridExtra")
library("maps")
library("rsq")
library("parameters")
library("performance")
library("scatterpie")
library("tidyr")

# Sourcing useful functions ------------------------------------------------

source("Functions/Functions_bat.R")

###############################################################

## Data preparation:

###############################################################

# Loading the Database ----------------------------------------------------

db <-
  read.csv(
    file = "Data/database_bat_conservation.csv",
    sep = '\t',
    dec = ',',
    header = TRUE,
    as.is = FALSE
  )

str(db)

# How many study consider bats and other groups?

a <- ifelse(table(db$ID, db$Taxon_Group)>0,1,0)
table(rowSums(a))

sum(table(rowSums(a))[c(2,3)])/sum(table(rowSums(a)))*100 #3.5 % of studies consider multiple organisms

# Selecting only bats
db <- db[db$Taxon_Group == "Bats",] ; db <- droplevels(db)

#Database only with distinct paper
db_unique <- distinct(db, ID, .keep_all = TRUE) 

#Checking levels of factors
levels(db$Taxon_Group)
levels(db$Tested_statistically)
levels(db$Higher_Geography)
levels(db$System)
levels(db$Domain)
levels(db$Taxon_Group)
levels(db$Impact)
levels(db$Conservation_Group)
levels(db$Conservation_Action)

#Type of actions
table(db$Publication_type)

#Summary statistics (Literature)
table(db_unique$Source) ; sum(table(db_unique$Source)) # N° of unique sources

mean(table(db$ID)) ; SE(table(db$ID)) # mean number of actions/paper

#Summary statistics (Testing)
table(db$Tested_statistically)[2] / sum(table(db$Tested_statistically)) #N° and % testing

#How many estimates would be usable for meta analysis?
n_studies    <- c() 
n_estimates  <- c()
perc_testing <- c()
usable       <- c()
unusable     <- c()
perc_usable  <- c()

for(i in 1:nlevels(db$Conservation_Action)){

  db_i_tot <- db[db$Conservation_Action == levels(db$Conservation_Action)[i],]
  db_i     <- db_i_tot[db_i_tot$Tested_statistically == "yes",]
  
  table_i        <- table(db_i$Pearson_r_conversion) #% of usable statistics
  n_studies      <- c(n_studies, nrow(distinct(db_i, ID, .keep_all = TRUE)) ) #unique studies
  n_estimates    <- c(n_estimates, nrow(db_i) ) #unique estimates
  perc_testing   <- c(perc_testing, round(nrow(db_i)/nrow(db_i_tot),2)*100 )
  usable         <- c(usable, sum(table_i[1],table_i[3]))
  unusable       <- c(unusable, sum(table_i[2]))
  perc_usable    <- c(perc_usable, round((usable[i]/sum(table_i)),2)*100)
  
}

Table_1 <- data.frame(Intervention = levels(db$Conservation_Action), n_studies, n_estimates, perc_testing, usable, unusable, perc_usable)
Table_1[is.na(Table_1)] <- 0
colnames(Table_1) <- c("Intervention", "N° studies", "N° interventions", "% testing", "N° usable", "N° unusable", "% usable")

write.csv(Table_1,"Tables/Table_1.csv")

#Redefining impact
db$Impact2 <- db$Impact

levels(db$Impact)[2] <- "Multiple"
levels(db$Impact)[8] <- "Subterranean\nhabitat change"
levels(db$Impact)[9] <- "Surface\nhabitat change"
                          

###############################################################

## Meta-Analysis

###############################################################

db_metafor <- db[db$Tested_statistically == "yes",]
db_metafor <- db_metafor[db_metafor$Pearson_r_conversion == "converted",]
db_metafor <- droplevels(db_metafor)

dim(db_metafor) #2361 standardized estimates
nlevels(db_metafor$ID) #250 references 

db_metafor <- db_metafor %>% select(ID, 
                             N,
                             Domain,
                             System,
                             Response_Group,
                             Predictor_Group,
                             r = Pearson.s_r)

# Derive Fischer's Z and its variance

db_metafor <- escalc(measure = "ZCOR", ri = r, ni = N, data = db_metafor)

table(db_metafor$Predictor_Group,db_metafor$Response_Group) # Disturbance reduction & Gate

# Gate
db_metafor <- db_metafor[db_metafor$Predictor_Group == "Gate" | db_metafor$Predictor_Group == "Disturbance reduction",] ; db_metafor <- droplevels(db_metafor)

#Check sample size for each predictors
table_n <- data.frame(predictor = NULL, n = NULL, n_papers = NULL)

for(i in 1:length(unique(levels(db_metafor$Response_Group))))
  table_n <- rbind(table_n, 
                          data.frame(predictor = levels(db_metafor$Response_Group)[i],
                                     n = nrow(db_metafor[db_metafor$Response_Group == levels(db_metafor$Response_Group)[i], ]),
                                     n_papers = length(unique(db_metafor[db_metafor$Response_Group == levels(db_metafor$Response_Group)[i], ]$ID)))  
                          
  )

actions_to_analyse    <- c("Gate", "Disturbance reduction")

SUBSET    <- list()
MODEL     <- list()

result_for_plot <- data.frame(label_action = NULL,
                              label_pred = NULL,
                              size = NULL,
                              b     = NULL,
                              ci.lb = NULL,
                              ci.ub = NULL,
                              ES    = NULL,
                              L     = NULL,
                              U     = NULL)

# Modelling
for (j in 1:length(actions_to_analyse)){ 
  
  data_j  <- db_metafor[db_metafor$Predictor_Group == actions_to_analyse[j], ] ; data_j <- droplevels(data_j)
  
  predictors_to_analyse <- levels(data_j$Response_Group)
  
  
  for (i in 1:length(predictors_to_analyse)){  
    
    #subset the predictor
    data_i  <- data_j[data_j$Response_Group == predictors_to_analyse[i], ]
    
    #fitting the model
    model_i <- rma.mv(yi, vi, random =  ~ 1 | ID, data = na.omit(data_i)) 
    
    #extracting coefficients
    result_for_plot_i <- data.frame(label_action =  actions_to_analyse[j],
                                  label_pred = paste(predictors_to_analyse[i]," (" ,
                                                  nrow(data_i),", ",
                                                  length(unique(data_i$ID)),")",sep=''),
                                    size = length(unique(data_i$ID)),
                                    b     = model_i$b,
                                    ci.lb = model_i$ci.lb,
                                    ci.ub = model_i$ci.ub,
                                    ES    = ((exp(model_i$b)-1))/((exp(model_i$b)+1)),
                                    L     = ((exp(model_i$ci.lb)-1)/(exp(model_i$ci.lb)+1)),
                                    U     = ((exp(model_i$ci.ub)-1)/(exp(model_i$ci.ub)+1)))
    
    
    #store the data 
    SUBSET[[i]]     <- data_i
    MODEL[[i]]      <- model_i
    result_for_plot <- rbind(result_for_plot,result_for_plot_i)
    
  }
}

rownames(result_for_plot) <- NULL

(meta_analysis <- ggplot(data= result_for_plot) +
     geom_hline(yintercept = 0, lty = 2, col = "grey50") +  # add a dotted line at x=1 after flip
     xlab("")+
     ylab("Effect size [r]")+
     geom_pointrange(aes(x=label_pred, y=ES, ymin=L, ymax=U, col= label_action, size = ), size= .5) + 
     scale_color_manual(values = c("darkmagenta","grey10"))+
     coord_flip() + 
     theme_custom() +
     theme(axis.text.y = element_text(face= c("plain","bold","plain","bold","plain")))) # flip coordinates (puts labels on y axis)

#Save figure
pdf(file = "Figure/Figure_XX.pdf", width = 7, height =5)
meta_analysis
dev.off()


# Conservation actions by Family ------------------------------------------


levels(db$Higher_Geography)
family_action <- semi_colon_splitter(input1 = db$Family,
                            input2 = db$Conservation_Action, 
                            names = c("Family","Action"))

levels(family_action$Family)

Graph_bipartite <- family_action %>% 
  dplyr::select(Family,Action) %>% 
  table() %>% 
  igraph::graph_from_incidence_matrix(directed = FALSE) %>% 
  tidygraph::as_tbl_graph(directed = FALSE)

# Graph_bipartite <- Graph_bipartite %>% tidygraph::activate(nodes) %>% 
#   left_join(rbind(data.frame(table(db$Taxon)),
#                   data.frame(table(db$Conservation_Action))), by = c("name" = "Var1"))


# Collapse it into an unipartite 
Graph_unipartite_full <- igraph::bipartite_projection(Graph_bipartite)

# Takes the unipartite project graph
Graph_unipartite <- Graph_unipartite_full$proj1  %>% as_tbl_graph(directed = FALSE) %>% 
  activate(edges) %>% #%>% mutate(weight = 1) 
  igraph::simplify(edge.attr.comb = "sum") %>% 
  as_tbl_graph


########################
# Plotting the network #
########################

#SpatialLayout
Graph_plot <- Graph_unipartite %>% 
  igraph::simplify(edge.attr.comb = "sum") 

# Graph_plot_bat <- to_subgraph(Graph_unipartite, to %in% c(9) | from %in% c(9), subset_by = "edges")$subgraph %>% 
#   igraph::simplify(edge.attr.comb = "sum") 

ggraph::ggraph(Graph_plot_bat,  layout_with_kk(Graph_plot)) +
   geom_edge_arc(aes(width=weight) , strength = .1,
                alpha = 0.1) +
  
  geom_node_point(fill="grey30", alpha = .8, 
                  aes(size=Freq), shape = 21) + 
  geom_node_text(aes(label = name), size=4, color="gray10", repel=TRUE, force = 10) +
  scale_color_gradient2("Connection strength",
                        low= "#f7fcfd",
                        mid = "#8c96c6",
                        high = "#4d004b") +
   theme_void() + theme(legend.position = "bottom",legend.direction = "horizontal") + coord_fixed()

Graph_bipartite %>%  igraph::simplify(edge.attr.comb = "sum") %>% 
  ggraph::ggraph(.,  layout = "bipartite") +
  geom_edge_link0(edge_colour = "grey66")+
  geom_node_point(alpha = .8, 
                  aes(size=Freq, fill=type), shape = 21) +
  scale_fill_manual(values=c("blue","red"))+
  scale_colour_manual(values=c("blue","red"))+
  geom_node_text(aes(label = name, color=type), size=4, repel=TRUE, force = 10) +
  
  theme_void() + theme(legend.position = "left",legend.direction = "horizontal") 
library(ade4) # If you have not already done so

bipartite_matrix <- as_incidence_matrix(Graph_bipartite)  # Extract the matrix

animal_jaccard <- dist.binary(bipartite_matrix, method=1, upper=TRUE, diag = FALSE) # Method #1 is "Jaccard Index"
conservation_jaccard <- dist.binary(t(bipartite_matrix), method=1, upper=TRUE, diag = FALSE) 

animal_jaccard <- as.matrix(animal_jaccard)   
diag(animal_jaccard)<-0

# women_jaccard          # Look at the matrix before you binarize
animal_jaccard <- ifelse(animal_jaccard>0.7, 1, 0)     # Binarize

# jaccard_women      # Take a look at the matrix if you like.

animal_jaccard <- graph_from_adjacency_matrix(animal_jaccard,    # Create an igraph network
                                              mode = "undirected")
plot(animal_jaccard)

# Network test ------------------------------------------------------------

library("tidyverse")
library("ggraph")
library("igraph")        
library("tidygraph")

db <- read.csv(file = "Data/Database_Practical_conservation.csv", sep='\t', dec='.',header=T,as.is=F)

db <- db[db$System != "Anchialine/Marine",] ; db <- droplevels(db)

levels(db$Taxon)[c(4,5,15,17)] <- "Omit"

levels(db$Taxon)[c(2,6,17,20)] <- "Other Invertebrates"

levels(db$Taxon)[c(5,11)] <- "Other Vertebrates"

levels(db$Taxon)[c(7,16)] <- "Microorganisms"

levels(db$Taxon)[10]    <- "Chiroptera"

db <- db[db$Taxon != "Omit",] ; db <- droplevels(db)

db <- db[db$Direction_of_effect != "Negative",] ; db <- droplevels(db)

Graph_bipartite <- db %>% 
  dplyr::select(Taxon,Conservation_Action) %>% 
  table() %>% 
  igraph::graph_from_incidence_matrix(directed = FALSE) %>% 
  tidygraph::as_tbl_graph(directed = FALSE) 

Graph_bipartite <- Graph_bipartite %>% tidygraph::activate(nodes) %>% 
  left_join(rbind(data.frame(table(db$Taxon)),
                  data.frame(table(db$Conservation_Action))), by = c("name" = "Var1"))


# Collapse it into an unipartite 
Graph_unipartite_full <- igraph::bipartite_projection(Graph_bipartite)

# Takes the unipartite project graph
Graph_unipartite <- Graph_unipartite_full$proj1  %>% as_tbl_graph(directed = FALSE) %>% 
  activate(edges) %>% #%>% mutate(weight = 1) 
  igraph::simplify(edge.attr.comb = "sum") %>% 
  as_tbl_graph


########################
# Plotting the network #
########################

#SpatialLayout
Graph_plot <- Graph_unipartite %>% 
    igraph::simplify(edge.attr.comb = "sum") 

Graph_plot_bat <- to_subgraph(Graph_unipartite, to %in% c(9) | from %in% c(9), subset_by = "edges")$subgraph %>% 
  igraph::simplify(edge.attr.comb = "sum") 

ggraph::ggraph(Graph_plot_bat,  layout_with_kk(Graph_plot)) +
    #geom_edge_density(fill="orange", alpha=1) +
    geom_edge_arc(aes(width=weight) , strength = .1,
                  alpha = 0.1) +
    
    geom_node_point(fill="grey30", alpha = .8, 
                    aes(size=Freq), shape = 21) + 
    geom_node_text(aes(label = name), size=4, color="gray10", repel=TRUE, force = 10) +
    scale_color_gradient2("Connection strength",
                          low= "#f7fcfd",
                          mid = "#8c96c6",
                          high = "#4d004b") +
    #scale_fill_manual(values = c("blue", "orange", "pink","purple", "grey15")) +
    theme_void() + theme(legend.position = "bottom",legend.direction = "horizontal") + coord_fixed()

citation("mgcv")

Graph_bipartite %>%  igraph::simplify(edge.attr.comb = "sum") %>% 
  ggraph::ggraph(.,  layout_with_kk(.)) +
   geom_edge_arc(
                 strength = .1,
                alpha = 0.3) +
   geom_node_point(alpha = .8, 
                  aes(size=Freq, fill=type), shape = 21) +
  scale_fill_manual(values=c("blue","red"))+
  scale_colour_manual(values=c("blue","red"))+
  geom_node_text(aes(label = name, color=type), size=4, repel=TRUE, force = 10) +
  
  theme_void() + theme(legend.position = "bottom",legend.direction = "horizontal") + coord_fixed()

library(ade4) # If you have not already done so

bipartite_matrix <- as_incidence_matrix(Graph_bipartite)  # Extract the matrix

animal_jaccard <- dist.binary(bipartite_matrix, method=1, upper=TRUE, diag = FALSE) # Method #1 is "Jaccard Index"
conservation_jaccard <- dist.binary(t(bipartite_matrix), method=1, upper=TRUE, diag = FALSE) 

animal_jaccard <- as.matrix(animal_jaccard)   
diag(animal_jaccard)<-0

# women_jaccard          # Look at the matrix before you binarize
animal_jaccard <- ifelse(animal_jaccard>0.7, 1, 0)     # Binarize

# jaccard_women      # Take a look at the matrix if you like.

animal_jaccard <- graph_from_adjacency_matrix(animal_jaccard,    # Create an igraph network
                                          mode = "undirected")
plot(animal_jaccard)



#Generalized exponential random graph model
library("ergm.count")
library("network")

AdjMatrix <- Graph_unipartite %>% get.adjacency(attr = "weight", sparse = FALSE) 
AdjMatrix %>% as.matrix %>% dim #square

ResponseNetwork <- as.network(AdjMatrix %>% as.matrix, 
                              directed = TRUE, 
                              matrix.type = "a", 
                              ignore.eval = FALSE, 
                              names.eval = "weight")  # Important! )

#levels(db$Taxon)[10] <- "A"

#Adding node-level attributes
ResponseNetwork %v% "Taxon"            <- as.character(db$Taxon)

ergm_count  <- ergm(ResponseNetwork ~ 
                      sum + 
                      nodefactor("Taxon", levels = "Chiroptera", form = "sum"),
                    control = control.ergm(
                      parallel = 10, #change with your parallel
                      MCMC.samplesize = 10000,
                      MCMLE.maxit = 100),
                    response = "weight", 
                    reference = ~ Poisson)
?nodefactor
summary(ergm_count)



# Check model
  mcmc.diagnostics(ergm_count) #good mixing of chains
  
  
Figure_s2 <-  ergm_count %>%
    summary %>%
  magrittr::extract2("coefficients") %>%
    data.frame %>%
    rownames_to_column("Variable") %>%
    left_join(ergm_count %>%
                confint %>%  # Grabbing the 95% confidence intervals
                data.frame %>%
                rename(Lower = 1, Upper = 2) %>% 
                rownames_to_column("Variable")) %>% 
    # mutate(Variable = fct_recode(Variable, 
    #                              "Edges" = "edges",
    #                              "Node factor" = "nodefactor.SEARCH_TYPE.Ecological complexity",
    #                              )  %>% 
    ggplot2::ggplot(aes(Variable, Estimate)) +
    geom_hline(lty = 2, yintercept = 0, col = "grey30") +
    geom_errorbar(aes(ymin = Lower, ymax = Upper), width = .2, size=1) +
    geom_point(size= 4) +
    theme_bw()+
    coord_flip()+
    labs(x="", y="Mean effect size (95% confidence interval)")
  
  
  
  


#####################################
### FIGURE 2:::::::::::::::::::::::::
#####################################

# Map ---------------------------------------------------------------------

levels(db$Higher_Geography)
pie1 <- semi_colon_splitter(input1 = db$Higher_Geography,
                            input2 = db$Tested_statistically, 
                            names = c("Higher_Geography","Tested_statistically"))

#summary stats
table(pie1$Higher_Geography) # tot
table(pie1$Higher_Geography)/sum(table(pie1$Higher_Geography)) # %

pie_1 <- data.frame(table(pie1$Higher_Geography,pie1$Tested_statistically))

radius <- data.frame(sqrt(table(pie1$Higher_Geography))) ; rownames(radius) <- NULL
n <- data.frame(table(pie1$Higher_Geography)) ; rownames(radius) <- NULL

pie <- data.frame(region = levels(pie_1$Var1),
                  n =  n$Freq,
                  long  = c(35, 140.0, -154.0, 82.0, -106.0, -57.0, 22.0),
                  lat  = c(2, -23.5, 21, 27.0, 49.0, -17.0, 49.0),
                  no = pie_1$Freq[1:nlevels(pie_1$Var1)],
                  yes = pie_1$Freq[c(nlevels(pie_1$Var1)+1):c(nrow(pie_1))],
                  radius = radius$Freq)

col_fig2 = c("darkmagenta","grey10")

# Loading data
world <- map_data("world")
#biog_regions <- raster::shapefile("Biogeographic_regions/regioni biogeografiche_Biological Review.shp")

map1 <- ggplot() +
    geom_map(map = world, data = world,
             aes(map_id = region), 
             color = "gray45", fill = "gray45", size = 0.3) +
  
    labs(title = NULL) +
  
    #Add bioregion
    # geom_path(data = fortify(biog_regions),
    #         aes(x = long, y = lat, group = group),
    #         color = 'grey70', size = .2) +
    
    #global
    annotate(geom="text", x=-154, y=35, label="Global",
             color="black")+
    
    #Palearctic
    annotate(geom="text", x=24, y=84, label="Palearctic",
             color="black")+
    
    #Nearctic
    annotate(geom="text", x=-108, y=84, label="Nearctic",
             color="black")+
    
    #Neotropical
    annotate(geom="text", x=-26.5, y=-28, label="Neotropical",
             color="black")+
    
    #Afrotropical
    annotate(geom="text", x=62, y=-3, label="Afrotropical",
             color="black")+
    
    #Afrotropical
    annotate(geom="text", x=86, y=39, label="Indomalaysian",
             color="black")+
    
    #Australasian
    annotate(geom="text", x=178, y=-29, label="Australasian",
             color="black")+
    
    theme_bw() +
    theme(
      axis.text.x  = element_blank(), 
      axis.text.y  = element_blank(),
      axis.title.y = element_blank(),
      axis.title.x = element_blank(), 
      axis.line.x = element_blank(), 
      axis.line.y = element_blank(),
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),                                          
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(), 
      axis.ticks = element_blank(),
      plot.margin = unit(c(1,1,1,1), 'cm'),
      plot.title = element_text(size = 18, vjust = 1, hjust = 0),
      legend.text = element_text(size = 12),          
      legend.title = element_blank(),                              
      legend.position = c(0.1, 0.2), 
      legend.key = element_blank(),
      legend.background = element_rect(color = "black", 
                                       fill = "white", 
                                       size = 2, linetype = "blank"))

(map2 <- map1 + geom_scatterpie(aes(x=long, y=lat, group=region, r=radius),
                                data=pie, cols = c("no","yes"), color=NA, alpha=.9) +
    geom_scatterpie_legend(pie$radius, x= -150, y= -45, n = 2,
                           labeller = function (x) x=c(min(pie$n),max(pie$n)))+
    #scale_fill_manual(values=col_fig2)
    scale_fill_manual("",labels=c("Not tested", "Tested"),values=col_fig2)
  + theme(legend.position = "top"))

# Barplots ----------------------------------------------------------------

## Tested statistically by Impact
bar_1 <- data.frame(table(db$Tested_statistically,db$Impact2))

levels(bar_1$Var2)[2] <- "Multiple"

#summary stats
table(db$Impact2) # tot
table(db$Impact2)/ sum(table(db$Impact2)) # %

bar_1$Var2 <- factor(bar_1$Var2,levels = c("Alien species\nPathogens","Climate\nchange","Overexploitation\nPoaching",
                                           "Pollution","Habitat change\n(subterranean)","Habitat change\n(surface)",     
                                           "Visitors", "Multiple", "None"))  

(bar_p1 <-  ggplot(bar_1, aes(x=Var2,y=Freq, fill=Var1)) +
    
    geom_bar(stat="identity",position=position_dodge(), color = "grey20")+
    geom_text(aes(label=Freq), vjust=-1, color="black",
              position = position_dodge(0.9), size=2.5)+
    
    ylim(0,320)+
    scale_fill_manual("",labels=c("Not tested", "Tested"),values=col_fig2)+
    labs(title=NULL, subtitle = NULL,x=NULL, y = "Frequency")+
    theme_custom()+
    theme(legend.position =  "none",
          axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
          plot.margin = unit(c(0.2,0.2,0.2,0.2), 'cm')) 
)

## Tested statistically by System
bar_3 <- semi_colon_splitter(input1 = db$System,
                             input2 = db$Tested_statistically, 
                             names = c("System","Tested_statistically"))
#summary stats
table(bar_3$System) # tot
table(bar_3$System) / sum(table(bar_3$System)) # %
sum(table(bar_3$System)[c(3,4,7)]) / sum(table(bar_3$System)) #terrestial systems (sum of show caves, caqves and artificial)

bar_3 <- data.frame(table(bar_3$Tested_statistically,bar_3$System))

#rename levels
levels(bar_3$Var2)[1] <- "Not specific"
levels(bar_3$Var2)[2] <- "Anchialine\n& Marine"
levels(bar_3$Var2)[5] <- "Fissural\nsystems"

#reoder
bar_3$Var2 <- factor(bar_3$Var2,levels = c("Anchialine\n& Marine","Groundwater",
                                           "Cave","Show cave","Fissural\nsystems",
                                           "Artificial",
                                           "Not specific"))

(bar_p2 <-  ggplot(bar_3, aes(x=Var2,y=Freq, fill=Var1)) +
    
    geom_bar(stat="identity",position=position_dodge(), color = "grey20")+
    geom_text(aes(label=Freq), vjust=-1, color="black",
              position = position_dodge(0.9), size=2.5)+
    
    ylim(0,810)+
    
    scale_fill_manual("",labels=c("Not tested", "Tested"),values=col_fig2)+
    labs(title=NULL, subtitle = NULL,x=NULL, y = "Frequency")+
    theme_custom()+
    theme(legend.position =  "none",
          axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
          plot.margin = unit(c(0.2,0.2,0.2,0.2), 'cm')) 
  )

## Tested statistically by taxon
bar_4 <- semi_colon_splitter(input1 = db$Taxon_Group,
                             input2 = db$Tested_statistically, 
                             names  = c("Taxon_Group","Tested_statistically"))

#summary stats
table(bar_4$Taxon_Group) # tot
table(bar_4$Taxon_Group) / sum(table(bar_4$Taxon_Group)) # %

bar_4 <- data.frame(table(bar_4$Tested_statistically, bar_4$Taxon_Group))


bar_4$Var2 <- factor(bar_4$Var2, levels = c("Arthropoda","Other invertebrates",
                                           "Bats","Other vertebrates",
                                           "Plants","Microorganisms",
                                           "Not specific"))

(bar_p3 <-  ggplot(bar_4, aes(x=Var2, y=Freq, fill=Var1)) +
    
    geom_bar(stat="identity",position=position_dodge(), alpha=1, color = "grey20")+
    geom_text(aes(label=Freq), vjust=-1, color="black",
              position = position_dodge(0.9), size=2.5)+
    ylim(0,442)+
    scale_fill_manual("",labels=c("Not tested", "Tested"),values=col_fig2)+
    labs(title=NULL, subtitle = NULL,x=NULL, y = NULL)+
    theme_custom()+
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
          plot.margin = unit(c(0.2,0.2,0.2,0.2), 'cm'))
  )

## Tested statistically by conservation action
bar_5 <- data.frame(table(db$Tested_statistically,db$Conservation_Action))

#summary stats
table(db$Conservation_Action) # tot
table(db$Conservation_Action) / sum(table(db$Conservation_Action)) # %

(bar_p4 <-  ggplot(bar_5, aes(x=Var2,y=Freq, fill=Var1)) +
    
    geom_bar(stat="identity",position=position_dodge(), alpha=1,color = "grey20")+
    geom_text(aes(label=Freq), vjust=-1, color="black",
              position = position_dodge(0.9), size=2.5)+
    ylim(0,420)+
    
    scale_fill_manual("",labels=c("Not tested", "Tested"),values=col_fig2)+
    labs(title=NULL, subtitle = NULL,x=NULL, y = NULL)+
    theme_custom()+
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 45, vjust = 1, hjust=1,
                                     face = c(rep("plain",3),"italic",rep("plain",13))),
          plot.margin = unit(c(0.2,0.2,0.2,0.2), 'cm'))
)

# Arrange on a grid -------------------------------------------------------

pdf(file = "Figure/Figure_2.pdf", width = 11, height =12)

ggpubr::ggarrange(map2,
                  ggpubr::ggarrange(bar_p2, 
                                    bar_p3, 
                  bar_p1, 
                  bar_p4, 
                  ncol = 2, nrow = 2, align = "hv",  labels = c("B","C","D","E")), 
                  common.legend = FALSE,
                  labels = "A",
                  nrow=2)

dev.off()

#####################################
### FIGURE 3:::::::::::::::::::::::::
#####################################

# Chord diagrams ----------------------------------------------------------

## CHORD DIAGRAM 1 - Conservation action vs Impact
## https://www.data-to-viz.com/graph/chord.html

levels(db$Conservation_Group)

chord_plot1  <- function(){
  require("gridGraphics")
  
  chord <- data.frame(Conservation_Action = db$Conservation_Group, Impact = db$Impact)
  
  ## Adding 'all' values
  
  chord_all <- chord[chord$Impact  == "All",]
  chord     <- chord[!chord$Impact == "All",] ; chord$Impact <- droplevels(chord$Impact)
  
  for(i in nrow(chord_all)) {
    
    chord_i <- chord_all[i,]
    
    chord_i2 <- data.frame(Conservation_Action = rep(chord_i$Conservation_Action, nlevels(chord$Impact)),
                           Impact  = levels(chord$Impact))
    
    chord_i2 <- chord_i2[!chord_i2$Impact == "None",]
    
    chord <- rbind(chord,chord_i2)
    
  }
  
  #renaming levels
  levels(chord$Impact) <- c("Alien species\nPathogens",
                            "Climate\nchange",
                            "None",
                            "Alien species\nPathogens",
                            "Overexploitation\nPoaching",
                            "Pollution",
                            "    Habitat change\n    (subterranean)",#space is needed for graphical reasons
                            "Habitat change\n(surface)",
                            "Visitors")
  
  mat <- data.frame(table(chord$Conservation_Action, chord$Impact))
  
  colnames(mat) <- c("from", "to", "value")
  
  levels(mat$from)
  levels(mat$to)
  
  nlevels(mat$from)
  nlevels(mat$to)
  
  order_l <- c("Education", "Restoration", "Regulation",
               "Monitoring", "Assessment", "Protection", 
               "Alien species\nPathogens","Pollution", 
               "Climate\nchange", "Habitat change\n(surface)",
               "Visitors" ,"Overexploitation\nPoaching",
               "    Habitat change\n    (subterranean)",#space is needed for graphical reasons
               "None")
  
  col_l <- c("lightcyan4","brown4","darkgoldenrod2","darkblue","cyan4","blueviolet",rep("grey30",nlevels(mat$to)))
  
  circos.clear()
  circos.par(start.degree =  -8,
             gap.after=c(rep(3,nlevels(mat$from)-1),10,rep(3,nlevels(mat$to)-1),10))
  
  circlize::chordDiagram(mat,
                         grid.border =1,
                         order = order_l,
                         grid.col = col_l
  )
}

chord_plot1()

#Convert as ggplot2 object
chord_plot1  <- cowplot::as_grob(chord_plot1)
chord_plot1  <- ggpubr::as_ggplot(chord_plot1)


pdf(file = "Figure/Figure_3_no_silouhette.pdf", width = 10, height = 10)
par(mar=c(2,2,2,2))
ggpubr::ggarrange(chord_plot1, nrow= 1, ncol = 1)
dev.off()

# Silouhettes where prepared by Irene Frigo with Adobe Illustrator and have been added to Figure 3 outside R, using the program Inkscape.

#####################################
### FIGURE 4:::::::::::::::::::::::::
#####################################

# Modeling temporal trends ---------------------------------------

#Overall temporal trend in testing
bar_1 <- data.frame(table(db_unique$Year_publication,db_unique$Tested_statistically)) ; colnames(bar_1) <- c("yr","Tested","N")
bar_1$yr <- as.numeric(as.character(bar_1$yr))

# Has the frequency of tested paper changed over time?
glm <- data.frame(yr = unique(bar_1$yr),
                  tested = bar_1[bar_1$Tested=="yes",]$N, 
                  untested = bar_1[bar_1$Tested=="no",]$N)

glm <- glm[glm$yr > 1999,] #selecting last 20 years

m1  <- glm(cbind(tested,untested) ~ yr, data = glm, family = "binomial")

performance::check_overdispersion(m1) #no
rsq::rsq(m1) #0.25
  
(pM1 <- parameters::model_parameters(m1))

y <- seq(from = min(glm$yr), to = max(glm$yr), 1)

(inset <- 
    ggplot()+
    xlab(NULL)+ 
    ylab("Proportion tested")+
    geom_line(aes(y = logisticline(y, m1), x = y), colour = "blueviolet",linetype="solid",size=1)+
    
    geom_ribbon(aes(ymax = logisticline_max(y, m1),
                    ymin = logisticline_min(y, m1),x = y),alpha = 0.3,fill="black")+
    
    geom_point(aes(y= ((glm$tested)/(glm$tested + glm$untested)),x=glm$yr), col = "black", alpha = 0.5)+
    
    annotate("text", x = 2011, y = 0.35,
             label =  paste("GLM (n= 22): ",
                            round(pM1$Coefficient[2],2),
                            " ± ",
                            round(pM1$SE[2],2),
                            "; p= ",
                            round(pM1$p[2],3),sep=''),size = 4)+
    
    theme_custom() )

  
#add missing years for the plot
yr <- seq(from = range(as.numeric(as.character(bar_1$yr)))[1], to = range(as.numeric(as.character(bar_1$yr)))[2], by = 1)
yr <- yr[!yr %in% bar_1$yr]

yr2 <- data.frame(yr = rep(yr,2),
                  Tested = c(rep("no",length(yr)),rep("yes",length(yr))),
                  N = rep(0,2*length(yr)))

bar_1 <- rbind(bar_1,yr2)

#plot
Plot_trend0 <- ggplot(bar_1, aes(x=yr, y=as.numeric(N), fill=Tested))+
  geom_bar(stat="identity",color = "grey20")+
  scale_x_continuous(breaks = seq(from = range(bar_1$yr)[1], 
                                  to = range(bar_1$yr)[2], by = 3),
                     labels = as.character(seq(from = range(bar_1$yr)[1],
                                               to = range(bar_1$yr)[2], by = 3))
                     
  )+ 
  scale_fill_manual("",labels=c("Not tested", "Tested"),values=col_fig2)+
  labs(title=NULL, 
       x=NULL, 
       y = "Frequency",
       subtitle = NULL)+
  theme_custom()+
  theme(legend.position = "top",
        plot.subtitle = element_text(size = 12, color = "#222222"),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'cm'))

#add the inset

(Plot_trend0 <- Plot_trend0  + annotation_custom(ggplotGrob(inset),xmin=1965,xmax=2000,ymin=20,ymax=65))

## B - Conservation actions

tot <- data.frame(table(db$Year_publication)) #total number of publication/year

# Creating a database
db_yr2    <- data.frame(table(db$Year_publication,db$Conservation_Group))
db_yr2    <- data.frame(db_yr2, tot = rep(tot$Freq,6)) ; colnames(db_yr2) <- c("yr","Cons","N","tot")
db_yr2$yr <- as.numeric(as.character(db_yr2$yr))

# Selecting papers from 2000 onward
db_yr2 <- db_yr2[db_yr2$yr > 1999,]

# Modelling the temporal trends
model   <- list()
par     <- list()

for (i in levels(factor(db_yr2$Cons))) {
  
  db_i <- db_yr2[db_yr2$Cons==i, ]
  model[[i]]   <- glm(cbind(N,tot) ~ yr, data = db_i, family = "binomial")
  par[[i]] <- parameters::model_parameters(model[[i]])
  
}  

# Model validation
performance::check_model(model[[1]])
performance::check_model(model[[2]])
performance::check_model(model[[3]])
performance::check_model(model[[4]])
performance::check_model(model[[5]])
performance::check_model(model[[6]])

# R^2
for (i in 1:nlevels(factor(db_yr2$Cons))) {
  
  message(paste("::::::  ",levels(factor(db_yr2$Cons))[i],"  :::::"))
  
  print(rsq::rsq(model[[i]]))   
  
} 

# Model summary 
for (i in 1:nlevels(factor(db_yr2$Cons))) {
  
  message(paste("::::::  ",levels(factor(db_yr2$Cons))[i],"  :::::"))
  
  print(parameters::model_parameters(model[[i]]))   
  
}  #Restoration and regulation significant

#Temporal series of interest
y2 <- seq(from = min(db_yr2$yr), to = max(db_yr2$yr), 1) #temporal series of interest

(Plot_trend1 <- ggplot() +
    ylab(NULL) + xlab(NULL)+ ylim(0,0.25)+
    #trend lines
    geom_line(aes(y = logisticline(y2,model[[1]]), x = y2), colour = COL[1],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model[[2]]), x = y2), colour = COL[2],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model[[3]]), x = y2), colour = COL[3],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model[[4]]), x = y2), colour = COL[4],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model[[5]]), x = y2), colour = COL[5],linetype="solid",size=1.1)+
    geom_line(aes(y = logisticline(y2,model[[6]]), x = y2), colour = COL[6],linetype="solid",size=1.1)+
    #confidence intervals
    geom_ribbon(aes(ymax = logisticline_max(y2, model[[01]]),
                    ymin = logisticline_min(y2, model[[01]]),x = y2),alpha = alpha2,fill=COL[1])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model[[02]]),
                    ymin = logisticline_min(y2, model[[02]]),x = y2),alpha = alpha2,fill=COL[2])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model[[03]]),
                    ymin = logisticline_min(y2, model[[03]]),x = y2),alpha = alpha2,fill=COL[3])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model[[04]]),
                    ymin = logisticline_min(y2, model[[04]]),x = y2),alpha = alpha2,fill=COL[4])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model[[05]]),
                    ymin = logisticline_min(y2, model[[05]]),x = y2),alpha = 0.5, fill=COL[5])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model[[06]]),
                    ymin = logisticline_min(y2, model[[06]]),x = y2),alpha = 0.5, fill=COL[6])+
    
    #Text
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model[[01]])[21]+0.005, 
             label = levels(factor(db_yr2$Cons))[1],
             color="black",alpha=alpha3)+
    
    annotate(geom="text", hjust = 0,vjust = 0,
             x= 2021.5, y= logisticline_max(y2, model[[02]])[21], 
             label = levels(factor(db_yr2$Cons))[2],
             color="black",alpha=alpha3)+
    
    annotate(geom="text", hjust = 0,vjust = 0,
             x= 2021.5, y= logisticline_max(y2, model[[03]])[21]-0.01, 
             label = levels(factor(db_yr2$Cons))[3],
             color="black",alpha=alpha3)+
    
    annotate(geom="text", hjust = 0,vjust = 0,
             x= 2021.5, y= logisticline_max(y2, model[[04]])[21], 
             label = levels(factor(db_yr2$Cons))[4],
             color="black",alpha=alpha3)+
    
    annotate(geom="text", hjust = 0,vjust = 0,
             x= 2021.5, y= logisticline_max(y2, model[[05]])[21], 
             label = levels(factor(db_yr2$Cons))[5],
             color=COL[5])+
    
    annotate(geom="text", hjust = 0,vjust = 0,
             x= 2021.5, y= logisticline_max(y2, model[[06]])[21], 
             label = levels(factor(db_yr2$Cons))[6],
             color=COL[6])+
    
    #annotation_custom(rasterGrob(img_Assessment), xmin = 2022, ymin = 0.2) +
    
    coord_cartesian(xlim = c(2000, 2021), # This focuses the x-axis on the range of interest
                    clip = 'off') +   # This keeps the labels from disappearing
    
    theme_custom() + theme(plot.margin = unit(c(0.5,4,0.5,0.5), 'cm'))
)

## C - Impacts

# Creating a database
db_yr3 <- data.frame(table(db$Year_publication,db$Impact2))
db_yr3 <- data.frame(db_yr3, tot = rep(tot$Freq, nlevels(db_yr3$Var2))) ; colnames(db_yr3) <- c("yr","Impact","N","tot")
db_yr3$yr <- as.numeric(as.character(db_yr3$yr))

# Selecting years and removing all
db_yr3 <- db_yr3[db_yr3$yr > 1999,]
db_yr3 <- db_yr3[!db_yr3$Impact == "All",]

# Modelling the temporal trends
model2 <- list()
par2   <- list()

for (i in levels(factor(db_yr3$Impact))) {
  
  db_i <- db_yr3[db_yr3$Impact==i, ]
  model2[[i]] <- glm(cbind(N,tot) ~ yr, data = db_i, family = "binomial")
  par2[[i]] <- parameters::model_parameters(model2[[i]])
  
} 

# R^2
for (i in 1:nlevels(factor(db_yr3$Impact))) {
  
  message(paste("::::::  ",levels(factor(db_yr3$Impact))[i],"  :::::"))
  
  print(rsq::rsq(model2[[i]]))   
  
} 

# Model summary 
for (i in 1:nlevels(factor(db_yr3$Impact))) {
  
  message(paste("::::::  ",levels(factor(db_yr3$Impact))[i],"  :::::"))
  
  print(parameters::model_parameters(model2[[i]]))   
  
}  #Pollution, Pathogens, Visitors significant, Climate change borderline significant.

#Renaming levels
levels(db_yr3$Impact)[1] <- "Alien species\n& Pathogens"
levels(db_yr3$Impact)[3] <- "Climate change"
levels(db_yr3$Impact)[5] <- "Overexploitation\n& Poaching"

(Plot_trend2 <- ggplot() +
    ylab("Proportion") + xlab(NULL) + ylim(0,0.25)+
    #trend lines
    #geom_line(aes(y = logisticline(y2,model2[[03]]), x = y2), colour = COL2[3],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model2[[04]]), x = y2), colour = COL2[4],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model2[[06]]), x = y2), colour = COL2[6],linetype="solid",size=1.1,alpha=alpha1)+
    geom_line(aes(y = logisticline(y2,model2[[07]]), x = y2), colour = COL2[7],linetype="solid",size=1.1,alpha=alpha1)+
    
    geom_line(aes(y = logisticline(y2,model2[[08]]), x = y2), colour = COL2[8],linetype="solid",size=1.1)+
    geom_line(aes(y = logisticline(y2,model2[[01]]), x = y2), colour = COL2[1],linetype="solid",size=1.1)+
    geom_line(aes(y = logisticline(y2,model2[[05]]), x = y2), colour = COL2[5],linetype="solid",size=1.1)+
    geom_line(aes(y = logisticline(y2,model2[[02]]), x = y2), colour = COL2[2],linetype="solid",size=1.1)+
    
    #confidence intervals
   #  geom_ribbon(aes(ymax = logisticline_max(y2, model2[[04]]),
   #                 ymin = logisticline_min(y2, model2[[04]]),x = y2),alpha = alpha2,fill=COL2[4])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model2[[06]]),
                    ymin = logisticline_min(y2, model2[[06]]),x = y2),alpha = alpha2,fill=COL2[6])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model2[[07]]),
                    ymin = logisticline_min(y2, model2[[07]]),x = y2),alpha = alpha2,fill=COL2[7])+
    
    geom_ribbon(aes(ymax = logisticline_max(y2, model2[[08]]),
                    ymin = logisticline_min(y2, model2[[08]]),x = y2),alpha = 0.4,fill=COL2[8])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model2[[01]]),
                    ymin = logisticline_min(y2, model2[[01]]),x = y2),alpha = 0.4,fill=COL2[1])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model2[[05]]),
                    ymin = logisticline_min(y2, model2[[05]]),x = y2),alpha = 0.4,fill=COL2[5])+
    geom_ribbon(aes(ymax = logisticline_max(y2, model2[[02]]),
                    ymin = logisticline_min(y2, model2[[02]]),x = y2),alpha = 0.4,fill=COL2[2])+
    
    #Text
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model2[[01]])[21]-0.03, 
             label = levels(factor(db_yr3$Impact))[1],
             color=COL2[1])+
    
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model2[[02]])[21], 
             label = levels(factor(db_yr3$Impact))[2],
             color=COL2[2])+
    
    annotate(geom="text", hjust = 0,vjust = 0,
             x= 2021.5, y= logisticline_max(y2, model2[[04]])[21]-0.015, 
             label = levels(factor(db_yr3$Impact))[4],
             color=COL2[4],alpha=alpha3)+
    
    
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model2[[05]])[21]+0.0035, 
             label = levels(factor(db_yr3$Impact))[5],
             color=COL2[5])+
    
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model2[[06]])[21]-0.01, 
             label = levels(factor(db_yr3$Impact))[6],
             color=COL2[6])+
    
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model2[[07]])[21], 
             label = levels(factor(db_yr3$Impact))[7],
             color=COL2[7])+
    
    annotate(geom="text", hjust = 0,vjust = 0.3,
             x= 2021.5, y= logisticline_max(y2, model2[[08]])[21]+0.01, 
             label = levels(factor(db_yr3$Impact))[8],
             color=COL2[8])+
    
    coord_cartesian(xlim = c(2000, 2021), # This focuses the x-axis on the range of interest
                    clip = 'off') +     # This keeps the labels from disappearing
    
    theme_custom() + theme(plot.margin = unit(c(0.5,4,0.5,0.5), 'cm'))
)


# Arrange on a grid -------------------------------------------------------

pdf(file = "Figure/Figure_4.pdf", width = 14, height = 10)

ggpubr::ggarrange(Plot_trend0, ggpubr::ggarrange(Plot_trend2, Plot_trend1,
                                                 ncol = 2, nrow = 1, 
                                                 labels  = c("B","C"),align = "hv"),
                  ncol = 1, nrow = 2, 
                  labels  = c("A"), 
                  heights = c(1,1),
                  widths  = c(1,1),
                  align = "v",
                  common.legend = FALSE) 

dev.off()

## End of main analysis ------------------

#######################################################
#######################################################
# Re-doing the analysis with only Web of Science papers
#######################################################
#######################################################

db_sub <- db[db$Source != "Other",] ; db_sub <- droplevels(db_sub)

db_sub_unique <- distinct(db_sub, ID, .keep_all = TRUE) 

#Overall temporal trend in testing
bar_1 <- data.frame(table(db_sub_unique$Year_publication,db_sub_unique$Tested_statistically)) ; colnames(bar_1) <- c("yr","Tested","N")
bar_1$yr <- as.numeric(as.character(bar_1$yr))

# Has the frequency of tested paper changed over time?
glm <- data.frame(yr = unique(bar_1$yr),
                  tested = bar_1[bar_1$Tested=="yes",]$N, 
                  untested = bar_1[bar_1$Tested=="no",]$N)

glm <- glm[glm$yr > 1999,] #selecting last 20 years

m1  <- glm(cbind(tested,untested) ~ yr, data = glm, family = "binomial")

(pM1 <- parameters::model_parameters(m1))

## B - Conservation actions

tot <- data.frame(table(db_sub$Year_publication)) #total number of publication/year

# Creating a database
db_sub_yr2    <- data.frame(table(db_sub$Year_publication,db_sub$Conservation_Group))
db_sub_yr2    <- data.frame(db_sub_yr2, tot = rep(tot$Freq,6)) ; colnames(db_sub_yr2) <- c("yr","Cons","N","tot")
db_sub_yr2$yr <- as.numeric(as.character(db_sub_yr2$yr))

# Selecting papers from 2000 onward
db_sub_yr2 <- db_sub_yr2[db_sub_yr2$yr > 1999,]

# Modelling the temporal trends
model   <- list()
par     <- list()

for (i in levels(factor(db_sub_yr2$Cons))) {
  
  db_sub_i <- db_sub_yr2[db_sub_yr2$Cons==i, ]
  model[[i]]   <- glm(cbind(N,tot) ~ yr, data = db_sub_i, family = "binomial")
  par[[i]] <- parameters::model_parameters(model[[i]])
  
}  

# Model summary 
for (i in 1:nlevels(factor(db_sub_yr2$Cons))) {
  
  message(paste("::::::  ",levels(factor(db_sub_yr2$Cons))[i],"  :::::"))
  
  print(parameters::model_parameters(model[[i]]))   
  
}  #Restoration and regulation significant


## C - Impacts

# Creating a database
db_sub_yr3 <- data.frame(table(db_sub$Year_publication,db_sub$Impact2))
db_sub_yr3 <- data.frame(db_sub_yr3, tot = rep(tot$Freq, nlevels(db_sub_yr3$Var2))) ; colnames(db_sub_yr3) <- c("yr","Impact","N","tot")
db_sub_yr3$yr <- as.numeric(as.character(db_sub_yr3$yr))

# Selecting years and removing all
db_sub_yr3 <- db_sub_yr3[db_sub_yr3$yr > 1999,]
db_sub_yr3 <- db_sub_yr3[!db_sub_yr3$Impact == "All",]

# Modelling the temporal trends
model2 <- list()
par2   <- list()

for (i in levels(factor(db_sub_yr3$Impact))) {
  
  db_sub_i <- db_sub_yr3[db_sub_yr3$Impact==i, ]
  model2[[i]] <- glm(cbind(N,tot) ~ yr, data = db_sub_i, family = "binomial")
  par2[[i]] <- parameters::model_parameters(model2[[i]])
  
} 

# Model summary 
for (i in 1:nlevels(factor(db_sub_yr3$Impact))) {
  
  message(paste("::::::  ",levels(factor(db_sub_yr3$Impact))[i],"  :::::"))
  
  print(parameters::model_parameters(model2[[i]]))   
  
}  

## End ------------------